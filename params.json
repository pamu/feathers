{
  "name": "fextensions",
  "tagline": "Future extensions",
  "body": "# fextensions (Future extensions)\r\n\r\nHandy operations on future which are not available in standard scala library\r\n\r\nIndex\r\n\r\n1. [Timeout](#timeout) Timeout after given duration if future does not complete\r\n\r\n2. [tryMap](#trymap) Handle both success and failure cases with map, no need to use recover.\r\n\r\n3. [tryFlatMap](#tryflatmap) flatMap which handles both the success and failure case.\r\n\r\n4. [retry](#retry) retry a future till it is successful.\r\n\r\n## timeout\r\n\r\nHelps timeout an future if its running for too long\r\n\r\n### timeout implementation:\r\n\r\n```scala\r\n\r\ndef timeout(duration: FiniteDuration)(implicit ec: ExecutionContext): Future[T] = {\r\n  val promise = Promise[T]()\r\n  lazyFuture.run().onComplete(promise tryComplete)\r\n  All.fextensionsActorSystem.scheduler.scheduleOnce(duration) {\r\n    promise tryFailure TimeoutException(s\"Future timeout after ${duration.toString()}\")\r\n  }\r\n  promise.future\r\n}\r\n\r\n```\r\n\r\n### usage:\r\n```scala\r\nimport com.fextensions.All._\r\nimport com.fextensions.ec.global\r\nimport scala.concurrent.duration._\r\n\r\n//F is a shortcut for future\r\nval longRunningWork = F {\r\n  Thread.sleep(10000)\r\n}\r\n\r\nval fastFuture = F {\r\n Thread.sleep(1000)\r\n}\r\n\r\nlongRunningWork.timeout(2 seconds).fallbackTo(fastFuture)\r\n\r\n//The above call will fallback to fastFuture if longRunningWork takes more than 2 seconds.\r\n\r\n\r\n```\r\n\r\n## tryMap \r\n\r\nmap on future only helps to handle the positive case when the future is successful. But tryMap helps\r\nhandle both the success and failure case without using recover\r\n\r\n### tryMap implementation:\r\n\r\n```scala\r\n\r\ndef tryMap[U](f: Try[T] => U)(implicit ec: ExecutionContext): Future[U] = {\r\n  val promise = Promise[U]()\r\n  future onComplete { result =>\r\n    promise.trySuccess(f(result))\r\n  }\r\n  promise.future\r\n}\r\n\r\n```\r\n\r\n### usage:\r\n\r\n```scala\r\n//F is a shortcut for Future\r\n\r\nimport com.fextensions.ec.global //execution context\r\nimport com.fextensions.All._ //get all methods and aliases into scope\r\nimport scala.util._\r\n\r\nF {\r\n  Thread.sleep(10000)\r\n  1L\r\n}.tryMap {\r\n case Success(value) => // handle positive case\r\n case Failure(th) => //handle negative case\r\n}\r\n\r\n//No need for recover \r\n\r\n\r\n```\r\n\r\n## tryFlatMap\r\n\r\nflatMap defined on future only allows you to  \r\n\r\n### tryFlatMap implementation:\r\n\r\n```scala\r\n\r\ndef tryFlatMap[U](f: Try[T] => Future[U])(implicit ec: ExecutionContext): Future[U] = {\r\n  val promise = Promise[U]()\r\n  future.onComplete { result =>\r\n    promise tryCompleteWith  f(result)\r\n  }\r\n  promise.future\r\n}\r\n\r\n```\r\n\r\n### usage:\r\n\r\n```scala\r\n\r\nimport com.fextensions.ec.global //execution context\r\nimport com.fextensions.All._ //get all methods and aliases into scope\r\nimport scala.util._\r\n\r\nval f = F {\r\n  Thread.sleep(10000)\r\n  1\r\n}\r\n\r\nf.tryFlatMap {\r\n case Success(value) => F.successful(value)\r\n case Failure(th) => F.successful(0)\r\n}\r\n\r\n\r\n```\r\n\r\n## retry\r\n\r\nretry a future until successful providing max retry limit\r\n\r\n### retry implementation\r\n\r\n```scala\r\n\r\n    def retry(retries: Int)(implicit ec: ExecutionContext): Future[T] = {\r\n      val promise = Promise[T]()\r\n      def helper(leftOver: Int): Unit = {\r\n        lazyFuture.run().tryForeach {\r\n          case Success(value) =>\r\n            promise.trySuccess(value)\r\n          case Failure(th) =>\r\n            if (leftOver > 0) helper(leftOver - 1)\r\n            else promise.tryFailure(th)\r\n        }\r\n      }\r\n      helper(retries)\r\n      promise.future\r\n    }\r\n\r\n```\r\n\r\n## usage:\r\n\r\n```scala                                                             \r\n\r\nimport com.fextensions.ec.global //execution context                  \r\nimport com.fextensions.All._ //get all methods and aliases into scope \r\nimport scala.util._\r\n\r\nval f =\r\nF {\r\n  doSomeStuff()\r\n}\r\n\r\n\r\nf.retry(3) //tries for 3 times if f keeps on failing\r\n\r\n\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}